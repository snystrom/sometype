---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```
# sometype

<!-- badges: start -->
<!-- badges: end -->

This is a collection of experiments implementing Option & Result types in (mostly) base R. The API draws most of its inspiration from the [Rust](https://www.rust-lang.org/) standard library ([Option<T>](https://doc.rust-lang.org/std/option/), [Result<T, E>](https://doc.rust-lang.org/std/result/)). 

Other packages have done something for `Option` ([maybe](https://cran.r-project.org/package=maybe), [optional](https://cran.r-project.org/package=optional), among others).

## Installation

And the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("remotes")
remotes::install_github("snystrom/sometype")
```

## R Option<T>

`sometype` implements an `Option` S3 type:

Options are useful for wrapping values that can be missing (`None`) or real (`Some`), forcing the user to handle them explicitly.

```{r, error=TRUE}
library(sometype)

div0 <- function(x, y) {
  if (y == 0) {
    return(none)
  } 

  some(x/y)
}

answer <- div0(10,2)

# This is not allowed
answer > 2
```

```{r}
# Explicitly handling the option allows comparison
unwrap(answer) > 2
```

```{r}
# Syntactic sugar allows auto-unwrapping 
# (this is probably a bad idea and I'll kill this later)
answer <- !div0(10,2)
answer == 5
```

```{r, error = TRUE}
# Unwrap(none) will crash
answer <- !div0(10,0)
```

### Option<T> constructors

Users can manually build `Option<T>` objects using `some()` and `none`, or by using the `option()` constructor.

```{r}
# Values become Some()
option(5)
```

```{r}
# Missing values become None
option(NULL)
```

```{r}
# Options can be manually constructed
some(5) 
```

```{r}
# none is a special keyword export!
none
```

Users can provide custom predicates to produce `Option<None>` from values.
```{r}
gt_five <- function(x) {
  x > 5
}

option(10, list(gt_five))
```

### Handling Options

```{r}
# Return a default value on None
unwrap_or(div0(1,0), 0)
```

```{r}
# Do a custom behavior on None
oh_no <- function() {
  print("Oh No!")
}

unwrap_or_else(div0(1,0), oh_no)
```

```{r, error=TRUE}
# Throw a specific error on None
expect(div0(1,0), "I divided by zero!")
```

### Differences from prior implementations

For better or for worse, R's type system allows amazing flexibility often allowing things to "just work". This however doesn't work well for a data structure (like an `option`) that we want to **force** users to handle.

`sometype`'s `option`s are designed for minimal compatability with the rest of the R ecosystem. The goal is that users **must** handle `options` before actual work can be done on them. Other packages do not implement this behavior.

To demonstrate:
```{r}
optional_five <- optional::option(5)
just_five <- maybe::just(5)
some_five <- sometype::some(5)
```

`optional` propagates the `option` type, but allows computation.
```{r}
optional_five + 1
```

```{r}
optional::none + 1
```

`maybe` errors on some operations.
```{r, error = TRUE}
# This errors! Good!
just_five + 1
```

But supports others:
```{r}
# Oh no!
just_five[1]
```

```{r}
# Oh no!
as.character(just_five)
```

`sometype` should fail on all base R operations
```{r, error = TRUE}
some_five + 1
```

```{r, error = TRUE}
some_five[1]
```

```{r, error = TRUE}
as.character(some_five)
```

If an `option` can be provided as a valid argument to a function that does not handle them and produce no errors: that's probably a [bug](https://github.com/snystrom/sometype/issues).
